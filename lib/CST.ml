(* Generated by ocaml-tree-sitter. *)
(*
   php grammar

   entrypoint: program
*)

open! Sexplib.Conv
open Tree_sitter_run

type pat_elseif = Token.t (* pattern [eE][lL][sS][eE][iI][fF] *)
[@@deriving sexp_of]

type pat_requ = Token.t (* pattern [rR][eE][qQ][uU][iI][rR][eE] *)
[@@deriving sexp_of]

type tok_prec_n1_pat_524a507 = Token.t
[@@deriving sexp_of]

type pat_else = Token.t (* pattern [eE][lL][sS][eE] *)
[@@deriving sexp_of]

type pat_endf =
  Token.t (* pattern [eE][nN][dD][fF][oO][rR][eE][aA][cC][hH] *)
[@@deriving sexp_of]

type pat_fn = Token.t (* pattern [fF][nN] *)
[@@deriving sexp_of]

type eof = Token.t
[@@deriving sexp_of]

type pat_ret = Token.t (* pattern [rR][eE][tT][uU][rR][nN] *)
[@@deriving sexp_of]

type pat_while = Token.t (* pattern [wW][hH][iI][lL][eE] *)
[@@deriving sexp_of]

type pat_endw = Token.t (* pattern [eE][nN][dD][wW][hH][iI][lL][eE] *)
[@@deriving sexp_of]

type pat_public = Token.t (* pattern [pP][uU][bB][lL][iI][cC] *)
[@@deriving sexp_of]

type pat_imples =
  Token.t (* pattern [iI][mM][pP][lL][eE][mM][eE][nN][tT][sS] *)
[@@deriving sexp_of]

type pat_defa = Token.t (* pattern [dD][eE][fF][aA][uU][lL][tT] *)
[@@deriving sexp_of]

type pat_endif = Token.t (* pattern [eE][nN][dD][iI][fF] *)
[@@deriving sexp_of]

type pat_prot = Token.t (* pattern [pP][rR][oO][tT][eE][cC][tT][eE][dD] *)
[@@deriving sexp_of]

type pat_requ_once =
  Token.t (* pattern [rR][eE][qQ][uU][iI][rR][eE][__][oO][nN][cC][eE] *)
[@@deriving sexp_of]

type name =
  Token.t (* pattern [_a-zA-Z\u00A1-\u00ff][_a-zA-Z\u00A1-\u00ff\d]* *)
[@@deriving sexp_of]

type pat_priv = Token.t (* pattern [pP][rR][iI][vV][aA][tT][eE] *)
[@@deriving sexp_of]

type pat_incl = Token.t (* pattern [iI][nN][cC][lL][uU][dD][eE] *)
[@@deriving sexp_of]

type var_modifier = Token.t (* pattern [vV][aA][rR] *)
[@@deriving sexp_of]

type pat_abst = Token.t (* pattern [aA][bB][sS][tT][rR][aA][cC][tT] *)
[@@deriving sexp_of]

type pat_name = Token.t (* pattern [nN][aA][mM][eE][sS][pP][aA][cC][eE] *)
[@@deriving sexp_of]

type pat_enum = Token.t (* pattern [eE][nN][uU][mM] *)
[@@deriving sexp_of]

type pat_if = Token.t (* pattern [iI][fF] *)
[@@deriving sexp_of]

type pat_throw = Token.t (* pattern [tT][hH][rR][oO][wW] *)
[@@deriving sexp_of]

type string_ = Token.t
[@@deriving sexp_of]

type shell_command_expression = Token.t
[@@deriving sexp_of]

type boolean = Token.t (* pattern [Tt][Rr][Uu][Ee]|[Ff][Aa][Ll][Ss][Ee] *)
[@@deriving sexp_of]

type pat_for = Token.t (* pattern [fF][oO][rR] *)
[@@deriving sexp_of]

type pat_endd =
  Token.t (* pattern [eE][nN][dD][dD][eE][cC][lL][aA][rR][eE] *)
[@@deriving sexp_of]

type heredoc = Token.t
[@@deriving sexp_of]

type float_ =
  Token.t (* pattern \d*(_\d+)*((\.\d*(_\d+)*\
  )?([eE][\+-]?\d+(_\d+)*\
  )|(\.\d\d*(_\d+)*\
  )([eE][\+-]?\d+(_\d+)*\
  )?) *)
[@@deriving sexp_of]

type php_tag = Token.t (* pattern <\?([pP][hH][pP]|=)? *)
[@@deriving sexp_of]

type pat_case = Token.t (* pattern [cC][aA][sS][eE] *)
[@@deriving sexp_of]

type pat_goto = Token.t (* pattern [gG][oO][tT][oO] *)
[@@deriving sexp_of]

type pat_ends = Token.t (* pattern [eE][nN][dD][sS][wW][iI][tT][cC][hH] *)
[@@deriving sexp_of]

type pat_fina = Token.t (* pattern [fF][iI][nN][aA][lL][lL][yY] *)
[@@deriving sexp_of]

type pat_f398476 = Token.t (* pattern xor|XOR *)
[@@deriving sexp_of]

type pat_b91d208 = Token.t (* pattern [^\s<][^<]* *)
[@@deriving sexp_of]

type pat_final = Token.t (* pattern [fF][iI][nN][aA][lL] *)
[@@deriving sexp_of]

type pat_try = Token.t (* pattern [tT][rR][yY] *)
[@@deriving sexp_of]

type pat_extends = Token.t (* pattern [eE][xX][tT][eE][nN][dD][sS] *)
[@@deriving sexp_of]

type pat_switch = Token.t (* pattern [sS][wW][iI][tT][cC][hH] *)
[@@deriving sexp_of]

type pat_inte = Token.t (* pattern [iI][nN][tT][eE][rR][fF][aA][cC][eE] *)
[@@deriving sexp_of]

type pat_match = Token.t (* pattern [mM][aA][tT][cC][hH] *)
[@@deriving sexp_of]

type pat_echo = Token.t (* pattern [eE][cC][hH][oO] *)
[@@deriving sexp_of]

type pat_incl_once =
  Token.t (* pattern [iI][nN][cC][lL][uU][dD][eE][__][oO][nN][cC][eE] *)
[@@deriving sexp_of]

type pat_endfor = Token.t (* pattern [eE][nN][dD][fF][oO][rR] *)
[@@deriving sexp_of]

type pat_func = Token.t (* pattern [fF][uU][nN][cC][tT][iI][oO][nN] *)
[@@deriving sexp_of]

type pat_e0610ac = Token.t (* pattern and|AND *)
[@@deriving sexp_of]

type pat_inst_ =
  Token.t (* pattern [iI][nN][sS][tT][aA][nN][cC][eE][oO][fF] *)
[@@deriving sexp_of]

type pat_cont = Token.t (* pattern [cC][oO][nN][tT][iI][nN][uU][eE] *)
[@@deriving sexp_of]

type primitive_type = [
    `Array of Token.t (* "array" *)
  | `Call of Token.t (* "callable" *)
  | `Iter of Token.t (* "iterable" *)
  | `Bool of Token.t (* "bool" *)
  | `Float of Token.t (* "float" *)
  | `Int of Token.t (* "int" *)
  | `Str of Token.t (* "string" *)
  | `Void of Token.t (* "void" *)
  | `Mixed of Token.t (* "mixed" *)
  | `Static of Token.t (* "static" *)
  | `False of Token.t (* "false" *)
  | `Null of Token.t (* "null" *)
]
[@@deriving sexp_of]

type pat_inst = Token.t (* pattern [iI][nN][sS][tT][eE][aA][dD][oO][fF] *)
[@@deriving sexp_of]

type null = Token.t (* pattern [nN][uU][lL][lL] *)
[@@deriving sexp_of]

type pat_as = Token.t (* pattern [aA][sS] *)
[@@deriving sexp_of]

type pat_fore = Token.t (* pattern [fF][oO][rR][eE][aA][cC][hH] *)
[@@deriving sexp_of]

type pat_catch = Token.t (* pattern [cC][aA][tT][cC][hH] *)
[@@deriving sexp_of]

type cast_type = [
    `Array of Token.t (* "array" *)
  | `Bin of Token.t (* "binary" *)
  | `Bool_c506ff1 of Token.t (* "bool" *)
  | `Bool_84e2c64 of Token.t (* "boolean" *)
  | `Double of Token.t (* "double" *)
  | `Int_fa7153f of Token.t (* "int" *)
  | `Int_157db7d of Token.t (* "integer" *)
  | `Float of Token.t (* "float" *)
  | `Obj of Token.t (* "object" *)
  | `Real of Token.t (* "real" *)
  | `Str of Token.t (* "string" *)
  | `Unset of Token.t (* "unset" *)
]
[@@deriving sexp_of]

type pat_class = Token.t (* pattern [cC][lL][aA][sS][sS] *)
[@@deriving sexp_of]

type pat_do = Token.t (* pattern [dD][oO] *)
[@@deriving sexp_of]

type pat_brk = Token.t (* pattern [bB][rR][eE][aA][kK] *)
[@@deriving sexp_of]

type pat_global = Token.t (* pattern [gG][lL][oO][bB][aA][lL] *)
[@@deriving sexp_of]

type pat_static = Token.t (* pattern [sS][tT][aA][tT][iI][cC] *)
[@@deriving sexp_of]

type automatic_semicolon = Token.t
[@@deriving sexp_of]

type pat_use = Token.t (* pattern [uU][sS][eE] *)
[@@deriving sexp_of]

type pat_48a4c46 = Token.t (* pattern or|OR *)
[@@deriving sexp_of]

type pat_const = Token.t (* pattern [cC][oO][nN][sS][tT] *)
[@@deriving sexp_of]

type pat_trait = Token.t (* pattern [tT][rR][aA][iI][tT] *)
[@@deriving sexp_of]

type anon_choice_COLON_5102e09 = [
    `COLON of Token.t (* ":" *)
  | `SEMI of Token.t (* ";" *)
]
[@@deriving sexp_of]

type integer = Token.t
[@@deriving sexp_of]

type named_label_statement = (name (*tok*) * Token.t (* ":" *))
[@@deriving sexp_of]

type variable_name = (Token.t (* "$" *) * name (*tok*))
[@@deriving sexp_of]

type namespace_name = (
    name (*tok*)
  * (Token.t (* "\\" *) * name (*tok*)) list (* zero or more *)
)
[@@deriving sexp_of]

type visibility_modifier = [
    `Pat_public of pat_public
  | `Pat_prot of pat_prot
  | `Pat_priv of pat_priv
]
[@@deriving sexp_of]

type abstract_modifier = pat_abst
[@@deriving sexp_of]

type string__ = [ `Str of string_ (*tok*) | `Here of heredoc (*tok*) ]
[@@deriving sexp_of]

type text =
  [
      `Tok_prec_n1_pat_524a507 of tok_prec_n1_pat_524a507 (*tok*)
    | `Pat_b91d208 of pat_b91d208
  ]
    list (* one or more *)
[@@deriving sexp_of]

type final_modifier = pat_final
[@@deriving sexp_of]

type namespace_aliasing_clause = (pat_as * name (*tok*))
[@@deriving sexp_of]

type static_modifier = pat_static
[@@deriving sexp_of]

type semicolon = [
    `Auto_semi of automatic_semicolon (*tok*)
  | `SEMI of Token.t (* ";" *)
]
[@@deriving sexp_of]

type anon_choice_pat_func_6731ab8 = [
    `Pat_func of pat_func
  | `Pat_const of pat_const
]
[@@deriving sexp_of]

type anonymous_function_use_clause = (
    pat_use
  * Token.t (* "(" *)
  * Token.t (* "&" *) option
  * variable_name
  * (Token.t (* "," *) * Token.t (* "&" *) option * variable_name)
      list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* ")" *)
)
[@@deriving sexp_of]

type namespace_name_as_prefix = [
    `BSLASH of Token.t (* "\\" *)
  | `Opt_BSLASH_name_name_BSLASH of (
        Token.t (* "\\" *) option
      * namespace_name
      * Token.t (* "\\" *)
    )
  | `Pat_name_BSLASH of (pat_name * Token.t (* "\\" *))
  | `Pat_name_opt_BSLASH_name_name_BSLASH of (
        pat_name
      * Token.t (* "\\" *) option
      * namespace_name
      * Token.t (* "\\" *)
    )
]
[@@deriving sexp_of]

type literal = [
    `Int of integer (*tok*)
  | `Float of float_ (*tok*)
  | `Str_ of string__
  | `Bool of boolean (*tok*)
  | `Null of null (*tok*)
]
[@@deriving sexp_of]

type relative_scope = [
    `Self of Token.t (* "self" *)
  | `Parent of Token.t (* "parent" *)
  | `Pat_static of static_modifier
]
[@@deriving sexp_of]

type modifier = [
    `Var_modi of var_modifier (*tok*)
  | `Visi_modi of visibility_modifier
  | `Static_modi of static_modifier
  | `Final_modi of final_modifier
  | `Abst_modi of abstract_modifier
]
[@@deriving sexp_of]

type reserved_identifier = [
    `Self of Token.t (* "self" *)
  | `Parent of Token.t (* "parent" *)
  | `Pat_static of static_modifier
]
[@@deriving sexp_of]

type namespace_use_group_clause = (
    anon_choice_pat_func_6731ab8 option
  * namespace_name
  * namespace_aliasing_clause option
)
[@@deriving sexp_of]

type qualified_name = (namespace_name_as_prefix * name (*tok*))
[@@deriving sexp_of]

type declare_directive = (
    [
        `Ticks of Token.t (* "ticks" *)
      | `Enco of Token.t (* "encoding" *)
      | `Strict_types of Token.t (* "strict_types" *)
    ]
  * Token.t (* "=" *)
  * literal
)
[@@deriving sexp_of]

type anon_choice_name_9dd129a = [
    `Name of name (*tok*)
  | `Rese_id of reserved_identifier
]
[@@deriving sexp_of]

type namespace_use_group = (
    Token.t (* "{" *)
  * namespace_use_group_clause
  * (Token.t (* "," *) * namespace_use_group_clause) list (* zero or more *)
  * Token.t (* "}" *)
)
[@@deriving sexp_of]

type named_type = [ `Name of name (*tok*) | `Qual_name of qualified_name ]
[@@deriving sexp_of]

type anon_choice_name_062e4f2 = [
    `Name of name (*tok*)
  | `Rese_id of reserved_identifier
  | `Qual_name of qualified_name
]
[@@deriving sexp_of]

type type_list = (
    named_type
  * (Token.t (* "|" *) * named_type) list (* zero or more *)
)
[@@deriving sexp_of]

type base_clause = (
    pat_extends
  * anon_choice_name_062e4f2
  * (Token.t (* "," *) * anon_choice_name_062e4f2) list (* zero or more *)
)
[@@deriving sexp_of]

type class_interface_clause = (
    pat_imples
  * anon_choice_name_062e4f2
  * (Token.t (* "," *) * anon_choice_name_062e4f2) list (* zero or more *)
)
[@@deriving sexp_of]

type namespace_use_clause = (
    anon_choice_name_062e4f2
  * namespace_aliasing_clause option
)
[@@deriving sexp_of]

type types = [
    `Opt_type of (
        Token.t (* "?" *)
      * [ `Named_type of named_type | `Prim_type of primitive_type ]
    )
  | `Named_type of named_type
  | `Prim_type of primitive_type
]
[@@deriving sexp_of]

type union_type = (
    types
  * (Token.t (* "|" *) * types) list (* zero or more *)
)
[@@deriving sexp_of]

type type_ = union_type
[@@deriving sexp_of]

type return_type = (Token.t (* ":" *) * type_)
[@@deriving sexp_of]

type anon_array_elem_init_rep_COMMA_array_elem_init_1dad3d4 = (
    array_element_initializer
  * (Token.t (* "," *) * array_element_initializer) list (* zero or more *)
)

and anon_choice_array_dest_08f4c18 = [
    `Array_dest of array_destructing
  | `Choice_cast_var of variable
]

and anon_choice_case_stmt_f1b35bc = [
    `Case_stmt of (
        pat_case
      * expression
      * anon_choice_COLON_5102e09
      * statement list (* zero or more *)
    )
  | `Defa_stmt of (
        pat_defa
      * anon_choice_COLON_5102e09
      * statement list (* zero or more *)
    )
]

and anon_choice_choice_array_dest_abfb170 = [
    `Choice_array_dest of anon_choice_array_dest_08f4c18
  | `Exp_EQGT_choice_array_dest of (
        expression * Token.t (* "=>" *) * anon_choice_array_dest_08f4c18
    )
]

and anon_choice_choice_list_dest_c865322 = [
    `Choice_list_dest of anon_choice_list_dest_bb41c20
  | `Exp_EQGT_choice_list_dest of (
        expression * Token.t (* "=>" *) * anon_choice_list_dest_bb41c20
    )
]

and anon_choice_class_cst_access_exp_18f5288 = [
    `Class_cst_access_exp of class_constant_access_expression
  | `Name of name (*tok*)
]

and anon_choice_list_dest_bb41c20 = [
    `List_dest of list_destructing
  | `Choice_cast_var of variable
]

and anon_choice_match_cond_exp_d891119 = [
    `Match_cond_exp of (
        match_condition_list * Token.t (* "=>" *) * expression
    )
  | `Match_defa_exp of (pat_defa * Token.t (* "=>" *) * expression)
]

and anon_choice_simple_param_5af5eb3 = [
    `Simple_param of (
        attribute_list option
      * type_ option
      * Token.t (* "&" *) option
      * variable_name
      * property_initializer option
    )
  | `Vari_param of (
        attribute_list option
      * type_ option
      * Token.t (* "&" *) option
      * Token.t (* "..." *)
      * variable_name
    )
  | `Prop_prom_param of (
        visibility_modifier
      * type_ option
      * variable_name
      * property_initializer option
    )
]

and argument = (
    named_label_statement option
  * [ `Vari_unpa of variadic_unpacking | `Exp of expression ]
)

and arguments = (
    Token.t (* "(" *)
  * (argument * (Token.t (* "," *) * argument) list (* zero or more *))
      option
  * Token.t (* "," *) option
  * Token.t (* ")" *)
)

and array_creation_expression = [
    `Array_LPAR_opt_array_elem_init_rep_COMMA_array_elem_init_opt_COMMA_RPAR of (
        Token.t (* "array" *)
      * Token.t (* "(" *)
      * anon_array_elem_init_rep_COMMA_array_elem_init_1dad3d4 option
      * Token.t (* "," *) option
      * Token.t (* ")" *)
    )
  | `LBRACK_opt_array_elem_init_rep_COMMA_array_elem_init_opt_COMMA_RBRACK of (
        Token.t (* "[" *)
      * anon_array_elem_init_rep_COMMA_array_elem_init_1dad3d4 option
      * Token.t (* "," *) option
      * Token.t (* "]" *)
    )
]

and array_destructing = (
    Token.t (* "[" *)
  * anon_choice_choice_array_dest_abfb170 option
  * (Token.t (* "," *) * anon_choice_choice_array_dest_abfb170 option)
      list (* zero or more *)
  * Token.t (* "]" *)
)

and array_element_initializer = [
    `Opt_AMP_exp of (Token.t (* "&" *) option * expression)
  | `Exp_EQGT_opt_AMP_exp of (
        expression
      * Token.t (* "=>" *)
      * Token.t (* "&" *) option
      * expression
    )
  | `Vari_unpa of variadic_unpacking
]

and attribute = (anon_choice_name_062e4f2 * arguments option)

and attribute_list =
  (
      Token.t (* "#[" *)
    * attribute
    * (Token.t (* "," *) * attribute) list (* zero or more *)
    * Token.t (* "]" *)
  )
    list (* one or more *)

and binary_expression = [
    `Un_exp_pat_inst__choice_qual_name of (
        unary_expression * pat_inst_ * class_type_designator
    )
  | `Exp_QMARKQMARK_exp of (expression * Token.t (* "??" *) * expression)
  | `Exp_pat_e0610ac_exp of (expression * pat_e0610ac * expression)
  | `Exp_pat_48a4c46_exp of (expression * pat_48a4c46 * expression)
  | `Exp_pat_f398476_exp of (expression * pat_f398476 * expression)
  | `Exp_BARBAR_exp of (expression * Token.t (* "||" *) * expression)
  | `Exp_AMPAMP_exp of (expression * Token.t (* "&&" *) * expression)
  | `Exp_BAR_exp of (expression * Token.t (* "|" *) * expression)
  | `Exp_HAT_exp of (expression * Token.t (* "^" *) * expression)
  | `Exp_AMP_exp of (expression * Token.t (* "&" *) * expression)
  | `Exp_EQEQ_exp of (expression * Token.t (* "==" *) * expression)
  | `Exp_BANGEQ_exp of (expression * Token.t (* "!=" *) * expression)
  | `Exp_LTGT_exp of (expression * Token.t (* "<>" *) * expression)
  | `Exp_EQEQEQ_exp of (expression * Token.t (* "===" *) * expression)
  | `Exp_BANGEQEQ_exp of (expression * Token.t (* "!==" *) * expression)
  | `Exp_LT_exp of (expression * Token.t (* "<" *) * expression)
  | `Exp_GT_exp of (expression * Token.t (* ">" *) * expression)
  | `Exp_LTEQ_exp of (expression * Token.t (* "<=" *) * expression)
  | `Exp_GTEQ_exp of (expression * Token.t (* ">=" *) * expression)
  | `Exp_LTEQGT_exp of (expression * Token.t (* "<=>" *) * expression)
  | `Exp_LTLT_exp of (expression * Token.t (* "<<" *) * expression)
  | `Exp_GTGT_exp of (expression * Token.t (* ">>" *) * expression)
  | `Exp_PLUS_exp of (expression * Token.t (* "+" *) * expression)
  | `Exp_DASH_exp of (expression * Token.t (* "-" *) * expression)
  | `Exp_DOT_exp of (expression * Token.t (* "." *) * expression)
  | `Exp_STAR_exp of (expression * Token.t (* "*" *) * expression)
  | `Exp_SLASH_exp of (expression * Token.t (* "/" *) * expression)
  | `Exp_PERC_exp of (expression * Token.t (* "%" *) * expression)
]

and callable_expression = [
    `Choice_choice_dyna_var_name of callable_variable
  | `Paren_exp of parenthesized_expression
  | `Array_crea_exp of array_creation_expression
  | `Str_ of string__
]

and callable_variable = [
    `Choice_dyna_var_name of variable_name_
  | `Subs_exp of subscript_expression
  | `Member_call_exp of (
        dereferencable_expression * Token.t (* "->" *) * member_name
      * arguments
    )
  | `Null_member_call_exp of (
        dereferencable_expression * Token.t (* "?->" *) * member_name
      * arguments
    )
  | `Scoped_call_exp of (
        scope_resolution_qualifier * Token.t (* "::" *) * member_name
      * arguments
    )
  | `Func_call_exp of (
        [
            `Name of name (*tok*)
          | `Rese_id of reserved_identifier
          | `Qual_name of qualified_name
          | `Choice_choice_choice_dyna_var_name of callable_expression
        ]
      * arguments
    )
]

and catch_clause = (
    pat_catch
  * Token.t (* "(" *)
  * type_list
  * variable_name option
  * Token.t (* ")" *)
  * compound_statement
)

and class_constant_access_expression = (
    scope_resolution_qualifier * Token.t (* "::" *)
  * anon_choice_name_9dd129a
)

and class_type_designator = [
    `Qual_name of qualified_name
  | `Name of name (*tok*)
  | `Rese_id of reserved_identifier
  | `Subs_exp of subscript_expression
  | `Member_access_exp of member_access_expression
  | `Null_member_access_exp of nullsafe_member_access_expression
  | `Scoped_prop_access_exp of scoped_property_access_expression
  | `Choice_dyna_var_name of variable_name_
]

and clone_expression = (Token.t (* "clone" *) * primary_expression)

and colon_block = (Token.t (* ":" *) * statement list (* zero or more *))

and compound_statement = (
    Token.t (* "{" *)
  * statement list (* zero or more *)
  * Token.t (* "}" *)
)

and const_declaration = const_declaration_

and const_declaration_ = (
    visibility_modifier option
  * pat_const
  * const_element
  * (Token.t (* "," *) * const_element) list (* zero or more *)
  * semicolon
)

and const_element = (
    anon_choice_name_9dd129a * Token.t (* "=" *) * expression
)

and declaration_list = (
    Token.t (* "{" *)
  * member_declaration list (* zero or more *)
  * Token.t (* "}" *)
)

and dereferencable_expression = [
    `Choice_cast_var of variable
  | `Class_cst_access_exp of class_constant_access_expression
  | `Paren_exp of parenthesized_expression
  | `Array_crea_exp of array_creation_expression
  | `Name of name (*tok*)
  | `Rese_id of reserved_identifier
  | `Qual_name of qualified_name
  | `Str_ of string__
]

and dynamic_variable_name = [
    `DOLLAR_choice_dyna_var_name of (Token.t (* "$" *) * variable_name_)
  | `DOLLAR_LCURL_exp_RCURL of (
        Token.t (* "$" *) * Token.t (* "{" *) * expression
      * Token.t (* "}" *)
    )
]

and else_clause = (pat_else * statement)

and else_clause_2 = (pat_else * colon_block)

and else_if_clause = (pat_elseif * parenthesized_expression * statement)

and else_if_clause_2 = (pat_elseif * parenthesized_expression * colon_block)

and enum_declaration_list = (
    Token.t (* "{" *)
  * enum_member_declaration list (* zero or more *)
  * Token.t (* "}" *)
)

and enum_member_declaration = [
    `Enum_case of (
        attribute_list option
      * Token.t (* "case" *)
      * name (*tok*)
      * (
            Token.t (* "=" *)
          * [ `Str of string_ (*tok*) | `Int of integer (*tok*) ]
        )
          option
      * semicolon
    )
  | `Meth_decl of method_declaration
  | `Use_decl of use_declaration
]

and exponentiation_expression = (
    [ `Clone_exp of clone_expression | `Prim_exp of primary_expression ]
  * Token.t (* "**" *)
  * [
        `Expo_exp of exponentiation_expression
      | `Clone_exp of clone_expression
      | `Prim_exp of primary_expression
    ]
)

and expression = [
    `Cond_exp of (
        expression
      * Token.t (* "?" *)
      * expression option
      * Token.t (* ":" *)
      * expression
    )
  | `Match_exp of (pat_match * parenthesized_expression * match_block)
  | `Augm_assign_exp of (
        variable
      * [
            `STARSTAREQ of Token.t (* "**=" *)
          | `STAREQ of Token.t (* "*=" *)
          | `SLASHEQ of Token.t (* "/=" *)
          | `PERCEQ of Token.t (* "%=" *)
          | `PLUSEQ of Token.t (* "+=" *)
          | `DASHEQ of Token.t (* "-=" *)
          | `DOTEQ of Token.t (* ".=" *)
          | `LTLTEQ of Token.t (* "<<=" *)
          | `GTGTEQ of Token.t (* ">>=" *)
          | `AMPEQ of Token.t (* "&=" *)
          | `HATEQ of Token.t (* "^=" *)
          | `BAREQ of Token.t (* "|=" *)
          | `QMARKQMARKEQ of Token.t (* "??=" *)
        ]
      * expression
    )
  | `Assign_exp of (
        [ `Choice_cast_var of variable | `List_lit of list_literal ]
      * Token.t (* "=" *)
      * Token.t (* "&" *) option
      * expression
    )
  | `Yield_exp of (
        Token.t (* "yield" *)
      * [
            `Array_elem_init of array_element_initializer
          | `From_exp of (Token.t (* "from" *) * expression)
        ]
          option
    )
  | `Un_exp of unary_expression
  | `Bin_exp of binary_expression
  | `Incl_exp of (pat_incl * expression)
  | `Incl_once_exp of (pat_incl_once * expression)
  | `Requ_exp of (pat_requ * expression)
  | `Requ_once_exp of (pat_requ_once * expression)
]

and expressions = [ `Exp of expression | `Seq_exp of sequence_expression ]

and finally_clause = (pat_fina * compound_statement)

and foreach_pair = (expression * Token.t (* "=>" *) * foreach_value)

and foreach_value = [
    `Opt_AMP_exp of (Token.t (* "&" *) option * expression)
  | `List_lit of list_literal
]

and formal_parameters = (
    Token.t (* "(" *)
  * (
        anon_choice_simple_param_5af5eb3
      * (Token.t (* "," *) * anon_choice_simple_param_5af5eb3)
          list (* zero or more *)
    )
      option
  * Token.t (* "," *) option
  * Token.t (* ")" *)
)

and function_definition_header = (
    pat_func
  * Token.t (* "&" *) option
  * anon_choice_name_9dd129a
  * formal_parameters
  * return_type option
)

and list_destructing = (
    Token.t (* "list" *)
  * Token.t (* "(" *)
  * anon_choice_choice_list_dest_c865322 option
  * (Token.t (* "," *) * anon_choice_choice_list_dest_c865322 option)
      list (* zero or more *)
  * Token.t (* ")" *)
)

and list_literal = [
    `List_dest of list_destructing
  | `Array_dest of array_destructing
]

and match_block = (
    Token.t (* "{" *)
  * anon_choice_match_cond_exp_d891119
  * (Token.t (* "," *) * anon_choice_match_cond_exp_d891119)
      list (* zero or more *)
  * Token.t (* "," *) option
  * Token.t (* "}" *)
)

and match_condition_list = (
    expression
  * (Token.t (* "," *) * expression) list (* zero or more *)
)

and member_access_expression = (
    dereferencable_expression * Token.t (* "->" *) * member_name
)

and member_declaration = [
    `Class_const_decl of (
        attribute_list option
      * final_modifier option
      * const_declaration
    )
  | `Prop_decl of (
        attribute_list option
      * modifier list (* one or more *)
      * type_ option
      * property_element
      * (Token.t (* "," *) * property_element) list (* zero or more *)
      * semicolon
    )
  | `Meth_decl of method_declaration
  | `Use_decl of use_declaration
]

and member_name = [
    `Choice_rese_id of [
        `Rese_id of reserved_identifier
      | `Name of name (*tok*)
      | `Choice_dyna_var_name of variable_name_
    ]
  | `LCURL_exp_RCURL of (Token.t (* "{" *) * expression * Token.t (* "}" *))
]

and method_declaration = (
    attribute_list option
  * modifier list (* zero or more *)
  * function_definition_header
  * [ `Comp_stmt of compound_statement | `Choice_auto_semi of semicolon ]
)

and nullsafe_member_access_expression = (
    dereferencable_expression * Token.t (* "?->" *) * member_name
)

and object_creation_expression = [
    `New_choice_qual_name_opt_args of (
        Token.t (* "new" *)
      * class_type_designator
      * arguments option
    )
  | `New_pat_class_opt_args_opt_base_clause_opt_class_inte_clause_decl_list of (
        Token.t (* "new" *)
      * pat_class
      * arguments option
      * base_clause option
      * class_interface_clause option
      * declaration_list
    )
]

and parenthesized_expression = (
    Token.t (* "(" *) * expression * Token.t (* ")" *)
)

and primary_expression = [
    `Choice_cast_var of variable
  | `Choice_int of literal
  | `Class_cst_access_exp of class_constant_access_expression
  | `Qual_name of qualified_name
  | `Name of name (*tok*)
  | `Array_crea_exp of array_creation_expression
  | `Print_intr of (Token.t (* "print" *) * expression)
  | `Anon_func_crea_exp of (
        static_modifier option
      * pat_func
      * Token.t (* "&" *) option
      * formal_parameters
      * anonymous_function_use_clause option
      * return_type option
      * compound_statement
    )
  | `Arrow_func of (
        static_modifier option
      * pat_fn
      * Token.t (* "&" *) option
      * formal_parameters
      * return_type option
      * Token.t (* "=>" *)
      * expression
    )
  | `Obj_crea_exp of object_creation_expression
  | `Update_exp of update_expression
  | `Shell_cmd_exp of shell_command_expression (*tok*)
  | `Paren_exp of parenthesized_expression
  | `Throw_exp of (pat_throw * expression)
]

and property_element = (variable_name * property_initializer option)

and property_initializer = (Token.t (* "=" *) * expression)

and scope_resolution_qualifier = [
    `Rela_scope of relative_scope
  | `Name of name (*tok*)
  | `Rese_id of reserved_identifier
  | `Qual_name of qualified_name
  | `Dere_exp of dereferencable_expression
]

and scoped_property_access_expression = (
    scope_resolution_qualifier * Token.t (* "::" *) * variable_name_
)

and sequence_expression = (
    expression
  * Token.t (* "," *)
  * [ `Seq_exp of sequence_expression | `Exp of expression ]
)

and statement = [
    `Empty_stmt of Token.t (* ";" *)
  | `Comp_stmt of compound_statement
  | `Named_label_stmt of named_label_statement
  | `Exp_stmt of (expression * semicolon)
  | `If_stmt of (
        pat_if
      * parenthesized_expression
      * [
            `Choice_empty_stmt_rep_else_if_clause_opt_else_clause of (
                statement
              * else_if_clause list (* zero or more *)
              * else_clause option
            )
          | `Colon_blk_rep_else_if_clause_2_opt_else_clause_2_pat_endif_choice_auto_semi of (
                colon_block
              * else_if_clause_2 list (* zero or more *)
              * else_clause_2 option
              * pat_endif
              * semicolon
            )
        ]
    )
  | `Switch_stmt of (pat_switch * parenthesized_expression * switch_block)
  | `While_stmt of (
        pat_while
      * parenthesized_expression
      * [
            `Choice_empty_stmt of statement
          | `Colon_blk_pat_endw_choice_auto_semi of (
                colon_block * pat_endw * semicolon
            )
        ]
    )
  | `Do_stmt of (
        pat_do * statement * pat_while * parenthesized_expression * semicolon
    )
  | `For_stmt of (
        pat_for
      * Token.t (* "(" *)
      * expressions option
      * Token.t (* ";" *)
      * expressions option
      * Token.t (* ";" *)
      * expressions option
      * Token.t (* ")" *)
      * [
            `Choice_auto_semi of semicolon
          | `Choice_empty_stmt of statement
          | `COLON_rep_choice_empty_stmt_pat_endfor_choice_auto_semi of (
                Token.t (* ":" *)
              * statement list (* zero or more *)
              * pat_endfor
              * semicolon
            )
        ]
    )
  | `Fore_stmt of (
        pat_fore
      * Token.t (* "(" *)
      * expression
      * pat_as
      * [ `Fore_pair of foreach_pair | `Choice_opt_AMP_exp of foreach_value ]
      * Token.t (* ")" *)
      * [
            `Choice_auto_semi of semicolon
          | `Choice_empty_stmt of statement
          | `Colon_blk_pat_endf_choice_auto_semi of (
                colon_block * pat_endf * semicolon
            )
        ]
    )
  | `Goto_stmt of (pat_goto * name (*tok*) * semicolon)
  | `Cont_stmt of (pat_cont * expression option * semicolon)
  | `Brk_stmt of (pat_brk * expression option * semicolon)
  | `Ret_stmt of (pat_ret * expression option * semicolon)
  | `Try_stmt of (
        pat_try
      * compound_statement
      * [ `Catch_clause of catch_clause | `Fina_clause of finally_clause ]
          list (* one or more *)
    )
  | `Decl_stmt of (
        Token.t (* "declare" *)
      * Token.t (* "(" *)
      * declare_directive
      * Token.t (* ")" *)
      * [
            `Choice_empty_stmt of statement
          | `COLON_rep_choice_empty_stmt_pat_endd_choice_auto_semi of (
                Token.t (* ":" *)
              * statement list (* zero or more *)
              * pat_endd
              * semicolon
            )
          | `Choice_auto_semi of semicolon
        ]
    )
  | `Echo_stmt of (pat_echo * expressions * semicolon)
  | `Unset_stmt of (
        Token.t (* "unset" *)
      * Token.t (* "(" *)
      * variable
      * (Token.t (* "," *) * variable) list (* zero or more *)
      * Token.t (* ")" *)
      * semicolon
    )
  | `Const_decl of const_declaration
  | `Func_defi of (
        attribute_list option
      * function_definition_header
      * compound_statement
    )
  | `Class_decl of (
        attribute_list option
      * [ `Final_modi of final_modifier | `Abst_modi of abstract_modifier ]
          option
      * pat_class
      * name (*tok*)
      * base_clause option
      * class_interface_clause option
      * declaration_list
      * semicolon option
    )
  | `Inte_decl of (
        pat_inte
      * name (*tok*)
      * base_clause option
      * declaration_list
    )
  | `Trait_decl of (pat_trait * name (*tok*) * declaration_list)
  | `Enum_decl of (
        attribute_list option
      * pat_enum
      * name (*tok*)
      * return_type option
      * class_interface_clause option
      * enum_declaration_list
    )
  | `Name_defi of (
        pat_name
      * [
            `Name_name_choice_auto_semi of (namespace_name * semicolon)
          | `Opt_name_name_comp_stmt of (
                namespace_name option
              * compound_statement
            )
        ]
    )
  | `Name_use_decl of (
        pat_use
      * anon_choice_pat_func_6731ab8 option
      * [
            `Name_use_clause_rep_COMMA_name_use_clause of (
                namespace_use_clause
              * (Token.t (* "," *) * namespace_use_clause)
                  list (* zero or more *)
            )
          | `Opt_BSLASH_name_name_BSLASH_name_use_group of (
                Token.t (* "\\" *) option
              * namespace_name
              * Token.t (* "\\" *)
              * namespace_use_group
            )
        ]
      * semicolon
    )
  | `Global_decl of (
        pat_global
      * variable_name_
      * (Token.t (* "," *) * variable_name_) list (* zero or more *)
      * semicolon
    )
  | `Func_static_decl of (
        static_modifier
      * static_variable_declaration
      * (Token.t (* "," *) * static_variable_declaration)
          list (* zero or more *)
      * semicolon
    )
]

and static_variable_declaration = (
    variable_name
  * property_initializer option
)

and subscript_expression = (
    dereferencable_expression
  * [
        `LBRACK_opt_exp_RBRACK of (
            Token.t (* "[" *)
          * expression option
          * Token.t (* "]" *)
        )
      | `LCURL_exp_RCURL of (
            Token.t (* "{" *) * expression * Token.t (* "}" *)
        )
    ]
)

and switch_block = [
    `LCURL_rep_choice_case_stmt_RCURL of (
        Token.t (* "{" *)
      * anon_choice_case_stmt_f1b35bc list (* zero or more *)
      * Token.t (* "}" *)
    )
  | `COLON_rep_choice_case_stmt_pat_ends_choice_auto_semi of (
        Token.t (* ":" *)
      * anon_choice_case_stmt_f1b35bc list (* zero or more *)
      * pat_ends
      * semicolon
    )
]

and unary_expression = [
    `Clone_exp of clone_expression
  | `Prim_exp of primary_expression
  | `Expo_exp of exponentiation_expression
  | `Un_op_exp of unary_op_expression
  | `Cast_exp of (
        Token.t (* "(" *) * cast_type * Token.t (* ")" *) * unary_expression
    )
]

and unary_op_expression = [
    `AT_exp of (Token.t (* "@" *) * expression)
  | `Choice_PLUS_exp of (
        [
            `PLUS of Token.t (* "+" *)
          | `DASH of Token.t (* "-" *)
          | `TILDE of Token.t (* "~" *)
          | `BANG of Token.t (* "!" *)
        ]
      * expression
    )
]

and update_expression = [
    `Choice_cast_var_PLUSPLUS of (variable * Token.t (* "++" *))
  | `Choice_cast_var_DASHDASH of (variable * Token.t (* "--" *))
  | `PLUSPLUS_choice_cast_var of (Token.t (* "++" *) * variable)
  | `DASHDASH_choice_cast_var of (Token.t (* "--" *) * variable)
]

and use_as_clause = (
    anon_choice_class_cst_access_exp_18f5288
  * pat_as
  * [
        `Opt_visi_modi_name of (visibility_modifier option * name (*tok*))
      | `Visi_modi_opt_name of (visibility_modifier * name (*tok*) option)
    ]
)

and use_declaration = (
    pat_use
  * anon_choice_name_062e4f2
  * (Token.t (* "," *) * anon_choice_name_062e4f2) list (* zero or more *)
  * [ `Use_list of use_list | `Choice_auto_semi of semicolon ]
)

and use_instead_of_clause = (
    anon_choice_class_cst_access_exp_18f5288 * pat_inst * name (*tok*)
)

and use_list = (
    Token.t (* "{" *)
  * (
        [
            `Use_inst_of_clause of use_instead_of_clause
          | `Use_as_clause of use_as_clause
        ]
      * semicolon
    )
      list (* zero or more *)
  * Token.t (* "}" *)
)

and variable = [
    `Cast_var of (
        Token.t (* "(" *) * cast_type * Token.t (* ")" *) * variable
    )
  | `Choice_choice_dyna_var_name of callable_variable
  | `Scoped_prop_access_exp of scoped_property_access_expression
  | `Member_access_exp of member_access_expression
  | `Null_member_access_exp of nullsafe_member_access_expression
]

and variable_name_ = [
    `Dyna_var_name of dynamic_variable_name
  | `Var_name of variable_name
]

and variadic_unpacking = (Token.t (* "..." *) * expression)
[@@deriving sexp_of]

type program = (
    text option
  * (php_tag (*tok*) * statement list (* zero or more *)) option
)
[@@deriving sexp_of]

type empty_statement (* inlined *) = Token.t (* ";" *)
[@@deriving sexp_of]

type comment (* inlined *) = Token.t
[@@deriving sexp_of]

type text_interpolation (* inlined *) = (
    Token.t (* "?>" *)
  * text option
  * [ `Php_tag of php_tag (*tok*) | `Eof of eof (*tok*) ]
)
[@@deriving sexp_of]

type goto_statement (* inlined *) = (pat_goto * name (*tok*) * semicolon)
[@@deriving sexp_of]

type optional_type (* inlined *) = (
    Token.t (* "?" *)
  * [ `Named_type of named_type | `Prim_type of primitive_type ]
)
[@@deriving sexp_of]

type namespace_use_declaration (* inlined *) = (
    pat_use
  * anon_choice_pat_func_6731ab8 option
  * [
        `Name_use_clause_rep_COMMA_name_use_clause of (
            namespace_use_clause
          * (Token.t (* "," *) * namespace_use_clause)
              list (* zero or more *)
        )
      | `Opt_BSLASH_name_name_BSLASH_name_use_group of (
            Token.t (* "\\" *) option
          * namespace_name
          * Token.t (* "\\" *)
          * namespace_use_group
        )
    ]
  * semicolon
)
[@@deriving sexp_of]

type anonymous_function_creation_expression (* inlined *) = (
    static_modifier option
  * pat_func
  * Token.t (* "&" *) option
  * formal_parameters
  * anonymous_function_use_clause option
  * return_type option
  * compound_statement
)
[@@deriving sexp_of]

type arrow_function (* inlined *) = (
    static_modifier option
  * pat_fn
  * Token.t (* "&" *) option
  * formal_parameters
  * return_type option
  * Token.t (* "=>" *)
  * expression
)
[@@deriving sexp_of]

type assignment_expression (* inlined *) = (
    [ `Choice_cast_var of variable | `List_lit of list_literal ]
  * Token.t (* "=" *)
  * Token.t (* "&" *) option
  * expression
)
[@@deriving sexp_of]

type augmented_assignment_expression (* inlined *) = (
    variable
  * [
        `STARSTAREQ of Token.t (* "**=" *)
      | `STAREQ of Token.t (* "*=" *)
      | `SLASHEQ of Token.t (* "/=" *)
      | `PERCEQ of Token.t (* "%=" *)
      | `PLUSEQ of Token.t (* "+=" *)
      | `DASHEQ of Token.t (* "-=" *)
      | `DOTEQ of Token.t (* ".=" *)
      | `LTLTEQ of Token.t (* "<<=" *)
      | `GTGTEQ of Token.t (* ">>=" *)
      | `AMPEQ of Token.t (* "&=" *)
      | `HATEQ of Token.t (* "^=" *)
      | `BAREQ of Token.t (* "|=" *)
      | `QMARKQMARKEQ of Token.t (* "??=" *)
    ]
  * expression
)
[@@deriving sexp_of]

type break_statement (* inlined *) = (
    pat_brk
  * expression option
  * semicolon
)
[@@deriving sexp_of]

type case_statement (* inlined *) = (
    pat_case
  * expression
  * anon_choice_COLON_5102e09
  * statement list (* zero or more *)
)
[@@deriving sexp_of]

type cast_expression (* inlined *) = (
    Token.t (* "(" *) * cast_type * Token.t (* ")" *) * unary_expression
)
[@@deriving sexp_of]

type cast_variable (* inlined *) = (
    Token.t (* "(" *) * cast_type * Token.t (* ")" *) * variable
)
[@@deriving sexp_of]

type class_const_declaration (* inlined *) = (
    attribute_list option
  * final_modifier option
  * const_declaration
)
[@@deriving sexp_of]

type class_declaration (* inlined *) = (
    attribute_list option
  * [ `Final_modi of final_modifier | `Abst_modi of abstract_modifier ]
      option
  * pat_class
  * name (*tok*)
  * base_clause option
  * class_interface_clause option
  * declaration_list
  * semicolon option
)
[@@deriving sexp_of]

type conditional_expression (* inlined *) = (
    expression
  * Token.t (* "?" *)
  * expression option
  * Token.t (* ":" *)
  * expression
)
[@@deriving sexp_of]

type continue_statement (* inlined *) = (
    pat_cont
  * expression option
  * semicolon
)
[@@deriving sexp_of]

type declare_statement (* inlined *) = (
    Token.t (* "declare" *)
  * Token.t (* "(" *)
  * declare_directive
  * Token.t (* ")" *)
  * [
        `Choice_empty_stmt of statement
      | `COLON_rep_choice_empty_stmt_pat_endd_choice_auto_semi of (
            Token.t (* ":" *)
          * statement list (* zero or more *)
          * pat_endd
          * semicolon
        )
      | `Choice_auto_semi of semicolon
    ]
)
[@@deriving sexp_of]

type default_statement (* inlined *) = (
    pat_defa
  * anon_choice_COLON_5102e09
  * statement list (* zero or more *)
)
[@@deriving sexp_of]

type do_statement (* inlined *) = (
    pat_do * statement * pat_while * parenthesized_expression * semicolon
)
[@@deriving sexp_of]

type echo_statement (* inlined *) = (pat_echo * expressions * semicolon)
[@@deriving sexp_of]

type enum_case (* inlined *) = (
    attribute_list option
  * Token.t (* "case" *)
  * name (*tok*)
  * (
        Token.t (* "=" *)
      * [ `Str of string_ (*tok*) | `Int of integer (*tok*) ]
    )
      option
  * semicolon
)
[@@deriving sexp_of]

type enum_declaration (* inlined *) = (
    attribute_list option
  * pat_enum
  * name (*tok*)
  * return_type option
  * class_interface_clause option
  * enum_declaration_list
)
[@@deriving sexp_of]

type expression_statement (* inlined *) = (expression * semicolon)
[@@deriving sexp_of]

type for_statement (* inlined *) = (
    pat_for
  * Token.t (* "(" *)
  * expressions option
  * Token.t (* ";" *)
  * expressions option
  * Token.t (* ";" *)
  * expressions option
  * Token.t (* ")" *)
  * [
        `Choice_auto_semi of semicolon
      | `Choice_empty_stmt of statement
      | `COLON_rep_choice_empty_stmt_pat_endfor_choice_auto_semi of (
            Token.t (* ":" *)
          * statement list (* zero or more *)
          * pat_endfor
          * semicolon
        )
    ]
)
[@@deriving sexp_of]

type foreach_statement (* inlined *) = (
    pat_fore
  * Token.t (* "(" *)
  * expression
  * pat_as
  * [ `Fore_pair of foreach_pair | `Choice_opt_AMP_exp of foreach_value ]
  * Token.t (* ")" *)
  * [
        `Choice_auto_semi of semicolon
      | `Choice_empty_stmt of statement
      | `Colon_blk_pat_endf_choice_auto_semi of (
            colon_block * pat_endf * semicolon
        )
    ]
)
[@@deriving sexp_of]

type function_call_expression (* inlined *) = (
    [
        `Name of name (*tok*)
      | `Rese_id of reserved_identifier
      | `Qual_name of qualified_name
      | `Choice_choice_choice_dyna_var_name of callable_expression
    ]
  * arguments
)
[@@deriving sexp_of]

type function_definition (* inlined *) = (
    attribute_list option
  * function_definition_header
  * compound_statement
)
[@@deriving sexp_of]

type function_static_declaration (* inlined *) = (
    static_modifier
  * static_variable_declaration
  * (Token.t (* "," *) * static_variable_declaration) list (* zero or more *)
  * semicolon
)
[@@deriving sexp_of]

type global_declaration (* inlined *) = (
    pat_global
  * variable_name_
  * (Token.t (* "," *) * variable_name_) list (* zero or more *)
  * semicolon
)
[@@deriving sexp_of]

type if_statement (* inlined *) = (
    pat_if
  * parenthesized_expression
  * [
        `Choice_empty_stmt_rep_else_if_clause_opt_else_clause of (
            statement
          * else_if_clause list (* zero or more *)
          * else_clause option
        )
      | `Colon_blk_rep_else_if_clause_2_opt_else_clause_2_pat_endif_choice_auto_semi of (
            colon_block
          * else_if_clause_2 list (* zero or more *)
          * else_clause_2 option
          * pat_endif
          * semicolon
        )
    ]
)
[@@deriving sexp_of]

type include_expression (* inlined *) = (pat_incl * expression)
[@@deriving sexp_of]

type include_once_expression (* inlined *) = (pat_incl_once * expression)
[@@deriving sexp_of]

type interface_declaration (* inlined *) = (
    pat_inte
  * name (*tok*)
  * base_clause option
  * declaration_list
)
[@@deriving sexp_of]

type match_conditional_expression (* inlined *) = (
    match_condition_list * Token.t (* "=>" *) * expression
)
[@@deriving sexp_of]

type match_default_expression (* inlined *) = (
    pat_defa * Token.t (* "=>" *) * expression
)
[@@deriving sexp_of]

type match_expression (* inlined *) = (
    pat_match * parenthesized_expression * match_block
)
[@@deriving sexp_of]

type member_call_expression (* inlined *) = (
    dereferencable_expression * Token.t (* "->" *) * member_name * arguments
)
[@@deriving sexp_of]

type namespace_definition (* inlined *) = (
    pat_name
  * [
        `Name_name_choice_auto_semi of (namespace_name * semicolon)
      | `Opt_name_name_comp_stmt of (
            namespace_name option
          * compound_statement
        )
    ]
)
[@@deriving sexp_of]

type nullsafe_member_call_expression (* inlined *) = (
    dereferencable_expression * Token.t (* "?->" *) * member_name * arguments
)
[@@deriving sexp_of]

type print_intrinsic (* inlined *) = (Token.t (* "print" *) * expression)
[@@deriving sexp_of]

type property_declaration (* inlined *) = (
    attribute_list option
  * modifier list (* one or more *)
  * type_ option
  * property_element
  * (Token.t (* "," *) * property_element) list (* zero or more *)
  * semicolon
)
[@@deriving sexp_of]

type property_promotion_parameter (* inlined *) = (
    visibility_modifier
  * type_ option
  * variable_name
  * property_initializer option
)
[@@deriving sexp_of]

type require_expression (* inlined *) = (pat_requ * expression)
[@@deriving sexp_of]

type require_once_expression (* inlined *) = (pat_requ_once * expression)
[@@deriving sexp_of]

type return_statement (* inlined *) = (
    pat_ret
  * expression option
  * semicolon
)
[@@deriving sexp_of]

type scoped_call_expression (* inlined *) = (
    scope_resolution_qualifier * Token.t (* "::" *) * member_name * arguments
)
[@@deriving sexp_of]

type simple_parameter (* inlined *) = (
    attribute_list option
  * type_ option
  * Token.t (* "&" *) option
  * variable_name
  * property_initializer option
)
[@@deriving sexp_of]

type switch_statement (* inlined *) = (
    pat_switch * parenthesized_expression * switch_block
)
[@@deriving sexp_of]

type throw_expression (* inlined *) = (pat_throw * expression)
[@@deriving sexp_of]

type trait_declaration (* inlined *) = (
    pat_trait * name (*tok*) * declaration_list
)
[@@deriving sexp_of]

type try_statement (* inlined *) = (
    pat_try
  * compound_statement
  * [ `Catch_clause of catch_clause | `Fina_clause of finally_clause ]
      list (* one or more *)
)
[@@deriving sexp_of]

type unset_statement (* inlined *) = (
    Token.t (* "unset" *)
  * Token.t (* "(" *)
  * variable
  * (Token.t (* "," *) * variable) list (* zero or more *)
  * Token.t (* ")" *)
  * semicolon
)
[@@deriving sexp_of]

type variadic_parameter (* inlined *) = (
    attribute_list option
  * type_ option
  * Token.t (* "&" *) option
  * Token.t (* "..." *)
  * variable_name
)
[@@deriving sexp_of]

type while_statement (* inlined *) = (
    pat_while
  * parenthesized_expression
  * [
        `Choice_empty_stmt of statement
      | `Colon_blk_pat_endw_choice_auto_semi of (
            colon_block * pat_endw * semicolon
        )
    ]
)
[@@deriving sexp_of]

type yield_expression (* inlined *) = (
    Token.t (* "yield" *)
  * [
        `Array_elem_init of array_element_initializer
      | `From_exp of (Token.t (* "from" *) * expression)
    ]
      option
)
[@@deriving sexp_of]

let dump_tree root =
  sexp_of_program root
  |> Print_sexp.to_stdout
